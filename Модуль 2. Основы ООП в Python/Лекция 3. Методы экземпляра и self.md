В прошлой лекции мы говорили о **данных**, хранимых в объектах — атрибутах. Но объекты умеют не только **хранить**, но и **действовать**. Для этого у них есть **методы**.
Методы — это **функции внутри класса**, которые описывают поведение объектов.

---
### Что такое метод экземпляра?
**Метод экземпляра** — это функция, определённая внутри класса, которая работает с конкретным объектом (экземпляром).  
Она имеет доступ ко всем его атрибутам и может их читать или изменять.
Пример:
```python
class Person:
    def __init__(self, name):
        self.name = name

    def say_hello(self):  # метод экземпляра
        print(f"Привет, меня зовут {self.name}")

p = Person("Анна")
p.say_hello()  # Привет, меня зовут Анна
```
Здесь `say_hello` — метод экземпляра. Он вызывается у объекта `p` и использует его атрибут `name`.

---
### Роль `self`
`self` — это **ссылка на текущий объект**, для которого вызывается метод.
- Первый аргумент метода экземпляра **всегда называется `self`** (по соглашению).
- Через `self` мы обращаемся к атрибутам и другим методам **этого же объекта**.
```python
def say_hello(self):
    print(self.name)
```
Это эквивалентно: «Возьми `name` из того объекта, у которого был вызван `say_hello()`».

---
### Почему нужен `self`?
Python не знает сам, к какому объекту относится метод.  
Когда мы пишем:
```python
p.say_hello()
```
Python преобразует это в:
```python
Person.say_hello(p)
```
То есть объект `p` **неявно передаётся как первый аргумент** — вот почему в определении метода `self` стоит первым.

---
### Вызов методов и работа с атрибутами
Методы могут:
- читать значения атрибутов;
- изменять их;
- вызывать другие методы.
Пример:
```python
class Counter:
    def __init__(self):
        self.value = 0

    def increment(self):
        self.value += 1

    def show(self):
        print(f"Значение: {self.value}")

c = Counter()
c.increment()
c.increment()
c.show()  # Значение: 2
```
Здесь мы увеличиваем значение счётчика и выводим его. Всё работает через `self`.

---
### Отличие метода от обычной функции
Метод **всегда привязан к объекту** и имеет доступ к его данным.  
Обычная функция — нет.
Сравни:
```python
def greet(name):
    print(f"Привет, {name}")  # обычная функция
```
и
```python
class Greeter:
    def __init__(self, name):
        self.name = name

    def greet(self):  # метод
        print(f"Привет, {self.name}")
```

---
### Можно ли не называть `self` именно так?
Можно, но **не нужно**.  
Python не требует строго имени `self`, но это принятое соглашение. Все опытные программисты используют `self`, и тебе тоже стоит.

---
### Внутренние вызовы методов
Методы могут вызывать друг друга через `self`.
```python
class Example:
    def method1(self):
        print("method1")

    def method2(self):
        self.method1()  # вызов другого метода
```

---
### Заключение
- Методы — это функции внутри класса.
- Первый параметр метода экземпляра — `self`, ссылающийся на объект.
- Через `self` можно читать и менять атрибуты, вызывать другие методы.
- Методы делают объекты **живыми и активными**, определяя их поведение.
