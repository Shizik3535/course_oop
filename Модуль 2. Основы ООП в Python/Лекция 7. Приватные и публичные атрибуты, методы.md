# Приватные и публичные атрибуты, методы
В прошлой лекции мы познакомились с методами класса и статическими методами. Сегодня мы рассмотрим **инкапсуляцию** — один из ключевых принципов ООП, и узнаем, как в Python реализуются **приватные** и **публичные** атрибуты.

---
### Что такое инкапсуляция?
**Инкапсуляция** — это принцип программирования, который подразумевает:
1. Объединение данных и методов, работающих с этими данными, в одном классе
2. Скрытие внутренних деталей реализации от внешнего мира
3. Контроль доступа к атрибутам и методам объекта

Инкапсуляция помогает защитить объект от неправильного использования и создаёт чёткий интерфейс взаимодействия с ним.

---
### Публичные атрибуты
По умолчанию в Python все атрибуты являются **публичными** — доступными для чтения и изменения извне класса.

```python
class Person:
    def __init__(self, name, age):
        self.name = name  # публичный атрибут
        self.age = age    # публичный атрибут
    
    def introduce(self):
        print(f"Меня зовут {self.name}, мне {self.age} лет")

person = Person("Анна", 25)
print(person.name)  # Анна - можно свободно читать
person.age = 26     # можно свободно изменять
```

---
### Приватные атрибуты
**Приватные** (или **частные**) атрибуты — это атрибуты, которые предназначены для использования только внутри класса и не должны быть доступны извне.

В Python приватные атрибуты создаются с помощью префикса `__` (двойное подчёркивание) перед именем атрибута:

```python
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner      # публичный атрибут
        self.__balance = balance  # приватный атрибут
    
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return True
        return False
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return True
        return False
    
    def get_balance(self):
        return self.__balance

account = BankAccount("Иван", 1000)
print(account.owner)       # Иван - публичный атрибут
# print(account.__balance)  # AttributeError - нельзя обратиться напрямую

# Правильный способ получить баланс
print(account.get_balance())  # 1000
```

---
### Как работает приватность в Python
В отличие от других языков программирования, Python не обеспечивает **абсолютную** приватность. Двойное подчёркивание (`__`) на самом деле преобразует имя атрибута с помощью **name mangling** (искажения имени):

```python
class Example:
    def __init__(self):
        self.__private = "Это приватно"

obj = Example()
# print(obj.__private)  # AttributeError

# Но можно получить доступ через измененное имя
print(obj._Example__private)  # "Это приватно"
```

Атрибут `__private` преобразуется в `_Example__private`. Это не настоящая защита, а скорее "джентльменское соглашение" — если имя начинается с `__`, не обращайтесь к нему напрямую.

---
### Защищённые атрибуты
Кроме публичных и приватных, в Python есть понятие **защищённых** атрибутов. Они помечаются префиксом `_` (одно подчеркивание):

```python
class Product:
    def __init__(self, name, price):
        self.name = name      # публичный
        self._price = price   # защищенный
        self.__id = id(self)  # приватный

product = Product("Ноутбук", 50000)
print(product.name)    # Ноутбук
print(product._price)  # 50000 - доступно, но лучше не обращаться напрямую
```

Защищённые атрибуты технически доступны извне, но одиночное подчеркивание сигнализирует: "это внутренняя реализация, будьте осторожны".

---
### Приватные методы
Не только атрибуты, но и методы могут быть приватными:

```python
class DataProcessor:
    def __init__(self, data):
        self.data = data
    
    def process_all(self):
        """Публичный метод, доступный извне"""
        processed_data = self.__clean_data()
        return self.__analyze(processed_data)
    
    def __clean_data(self):
        """Приватный метод для внутреннего использования"""
        return [x for x in self.data if x is not None]
    
    def __analyze(self, clean_data):
        """Приватный метод для внутреннего использования"""
        return sum(clean_data) / len(clean_data) if clean_data else 0

# Использование
dp = DataProcessor([1, 2, None, 4, 5])
result = dp.process_all()
print(result)  # 3.0

# dp.__clean_data()  # AttributeError - приватный метод недоступен
```

Приватные методы используются для реализации внутренней логики класса, которая не должна быть частью публичного интерфейса.

---
### Когда что использовать
1. **Публичные атрибуты и методы**:
   - Используйте для интерфейса класса
   - Для атрибутов, которые безопасно читать и изменять извне
2. **Защищённые атрибуты и методы** (с префиксом `_`):
   - Для внутренней реализации, но которая может понадобиться наследникам
   - Указывают "используйте с осторожностью"
3. **Приватные атрибуты и методы** (с префиксом `__`):
   - Для деталей реализации, которые могут измениться
   - Для атрибутов, которые никогда не должны изменяться напрямую

---
### Заключение
- **Инкапсуляция** — важный принцип ООП, который помогает скрыть детали реализации и защитить объект.
- **Публичные атрибуты** (без префикса) доступны всем.
- **Защищённые атрибуты** (с префиксом `_`) — сигнал "будьте осторожны".
- **Приватные атрибуты** (с префиксом `__`) — предназначены только для внутреннего использования.
- **Защищённые и приватные методы** (с префиксом `_` и `__`) - методы, имеющие такой же смысл, как и атрибуты.

Правильное использование инкапсуляции делает код более надёжным, понятным и устойчивым к изменениям.
