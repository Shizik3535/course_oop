# Наследование в объектно-ориентированном программировании
В предыдущем модуле мы изучили основы ООП: познакомились с классами и объектами, рассмотрели атрибуты и методы, научились инкапсулировать данные. Сегодня мы приступаем к изучению **наследования** — мощного инструмента, который позволяет создавать иерархии классов и избежать дублирования кода.

---
### Что такое наследование?
**Наследование** — это механизм, который позволяет одному классу (потомку или подклассу) получать все атрибуты и методы другого класса (родителя или суперкласса). При этом класс-потомок может расширять или изменять функциональность класса-родителя.

Этот механизм создан для решения двух основных задач:
1. **Повторное использование кода** — общую функциональность можно выделить в базовый класс и наследовать её.
2. **Моделирование иерархий** — создание логической структуры классов, отражающей реальные отношения между объектами.

---
### Базовый синтаксис наследования
В Python наследование реализуется очень просто. Достаточно при определении класса указать родительский класс в скобках:

```python
class ParentClass:
    """Родительский класс (суперкласс)"""
    def parent_method(self):
        print("Это метод родительского класса")

class ChildClass(ParentClass):
    """Дочерний класс (подкласс)"""
    def child_method(self):
        print("Это метод дочернего класса")

# Использование
child = ChildClass()
child.parent_method()  # "Это метод родительского класса"
child.child_method()   # "Это метод дочернего класса"
```

В этом примере `ChildClass` наследует все атрибуты и методы `ParentClass`, включая метод `parent_method()`.

---
### Как работает наследование
Когда вы создаёте объект дочернего класса, Python сначала ищет атрибуты и методы в самом дочернем классе. Если не находит, то ищет в родительском классе, затем в родителе родителя и так далее по цепочке наследования.

Это называется **порядок разрешения методов** (Method Resolution Order, MRO):

```python
print(ChildClass.__mro__)  # Показывает порядок поиска методов
```

---
### Переопределение методов
Дочерний класс может **переопределять** методы родительского класса, заменяя их своей реализацией:

```python
class Animal:
    def speak(self):
        return "Звук животного"

class Dog(Animal):
    def speak(self):
        return "Гав!"

class Cat(Animal):
    def speak(self):
        return "Мяу!"

dog = Dog()
cat = Cat()
print(dog.speak())  # "Гав!"
print(cat.speak())  # "Мяу!"
```

В этом примере классы `Dog` и `Cat` переопределяют метод `speak()`, предоставляя свою реализацию.

---
### Расширение методов с помощью super()
Иногда требуется не полностью заменить метод родителя, а расширить его функциональность. Для этого используется функция `super()`:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def introduce(self):
        return f"Меня зовут {self.name}, мне {self.age} лет."

class Student(Person):
    def __init__(self, name, age, university):
        super().__init__(name, age)  # вызов конструктора родителя
        self.university = university
    
    def introduce(self):
        base_intro = super().introduce()  # вызов метода родителя
        return f"{base_intro} Я учусь в {self.university}."

student = Student("Анна", 20, "МГУ")
print(student.introduce())  # "Меня зовут Анна, мне 20 лет. Я учусь в МГУ."
```

Функция `super()` позволяет вызвать метод из родительского класса, дополняя его функциональность, а не полностью переписывая.

---
### Множественное наследование
Python поддерживает **множественное наследование** — когда класс наследуется от нескольких родителей:

```python
class A:
    def method_a(self):
        return "Метод A"

class B:
    def method_b(self):
        return "Метод B"

class C(A, B):
    def method_c(self):
        return "Метод C"

c = C()
print(c.method_a())  # "Метод A"
print(c.method_b())  # "Метод B"
print(c.method_c())  # "Метод C"
```

При множественном наследовании класс получает атрибуты и методы от всех родителей.

---
### Проблема ромбовидного наследования (diamond problem)
При множественном наследовании может возникнуть так называемая **проблема ромбовидного наследования**:

```
     A
    / \
   B   C
    \ /
     D
```

Если класс `D` наследуется от классов `B` и `C`, которые в свою очередь наследуются от класса `A`, то возникает вопрос: какой метод будет вызван, если `A`, `B` и `C` имеют метод с одинаковым именем?

Python решает эту проблему с помощью специального алгоритма C3-линеаризации, который и определяет MRO — порядок поиска методов.

```python
class A:
    def method(self):
        return "A method"

class B(A):
    def method(self):
        return "B method"

class C(A):
    def method(self):
        return "C method"

class D(B, C):
    pass

d = D()
print(d.method())  # "B method" - определяется порядком наследования (B, C)
print(D.__mro__)   # Показывает порядок разрешения методов
```

---
### Наследование и атрибуты класса
Атрибуты класса также наследуются:

```python
class Shape:
    color = "чёрный"  # атрибут класса
    
    def __init__(self, name):
        self.name = name  # атрибут экземпляра

class Circle(Shape):
    radius = 0  # новый атрибут класса
    
    def __init__(self, name, radius):
        super().__init__(name)
        self.radius = radius

circle = Circle("Круг", 5)
print(circle.color)   # "чёрный" - унаследовано от Shape
print(circle.name)    # "Круг" - инициализировано через конструктор Shape
print(circle.radius)  # 5 - установлено в Circle
```

---
### Проверка наследования
Для проверки наследования можно использовать функцию `isinstance()` и `issubclass()`:

```python
class Animal:
    pass

class Dog(Animal):
    pass

dog = Dog()

print(isinstance(dog, Dog))     # True - dog это экземпляр Dog
print(isinstance(dog, Animal))  # True - dog это также экземпляр Animal
print(issubclass(Dog, Animal))  # True - Dog это подкласс Animal
```

---
### Абстрактные классы: введение
Иногда нужно создать базовый класс, который определяет интерфейс, но не предоставляет полной реализации. Такие классы называются **абстрактными**:

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def speak(self):
        """Этот метод должен быть реализован в дочерних классах"""
        pass

class Dog(Animal):
    def speak(self):
        return "Гав!"

# Нельзя создать экземпляр абстрактного класса
# animal = Animal()  # TypeError

dog = Dog()  # Можно создать экземпляр класса, реализующего все абстрактные методы
print(dog.speak())  # "Гав!"
```

Абстрактные классы — это тема для отдельной лекции, но важно знать, что они существуют и используются для создания "шаблонов" классов.

---
### Практические рекомендации по наследованию
1. **Не злоупотребляйте наследованием** — иногда композиция (включение одного объекта в другой) предпочтительнее.
2. **Используйте наследование для общего поведения** — если разные классы имеют общую функциональность, имеет смысл вынести её в базовый класс.
3. **Следуйте принципу подстановки Лисков** — объекты подклассов должны корректно заменять объекты базовых классов.
4. **Осторожно с множественным наследованием** — оно мощное, но может запутать код.

---
### Заключение
- **Наследование** — мощный механизм ООП, позволяющий классам получать атрибуты и методы от других классов.
- С помощью наследования можно **избежать дублирования кода** и создавать **иерархии классов**.
- Дочерние классы могут **переопределять** и **расширять** методы родителей.
- Python поддерживает **множественное наследование**, но использовать его следует с осторожностью.
- Для расширения функциональности родительских методов используйте `super()`.
