# Наследование в объектно-ориентированном программировании
В предыдущем модуле мы изучили основы ООП: познакомились с классами и объектами, рассмотрели атрибуты и методы, научились инкапсулировать данные. Сегодня мы приступаем к изучению **наследования** — мощного инструмента, который позволяет создавать иерархии классов и избежать дублирования кода.

---
### Что такое наследование?
**Наследование** — это механизм, который позволяет одному классу (потомку или подклассу) получать все атрибуты и методы другого класса (родителя или суперкласса). При этом класс-потомок может расширять или изменять функциональность класса-родителя.

Этот механизм создан для решения двух основных задач:
1. **Повторное использование кода** — общую функциональность можно выделить в базовый класс и наследовать её.
2. **Моделирование иерархий** — создание логической структуры классов, отражающей реальные отношения между объектами.

---
### Базовый синтаксис наследования
В Python наследование реализуется очень просто. Достаточно при определении класса указать родительский класс в скобках:

```python
class ParentClass:
    """Родительский класс (суперкласс)"""
    def parent_method(self):
        print("Это метод родительского класса")

class ChildClass(ParentClass):
    """Дочерний класс (подкласс)"""
    def child_method(self):
        print("Это метод дочернего класса")

# Использование
child = ChildClass()
child.parent_method()  # "Это метод родительского класса"
child.child_method()   # "Это метод дочернего класса"
```

В этом примере `ChildClass` наследует все атрибуты и методы `ParentClass`, включая метод `parent_method()`.

---
### Как работает наследование
Когда вы создаёте объект дочернего класса, Python сначала ищет атрибуты и методы в самом дочернем классе. Если не находит, то ищет в родительском классе, затем в родителе родителя и так далее по цепочке наследования.

Это называется **порядок разрешения методов** (Method Resolution Order, MRO):

```python
print(ChildClass.__mro__)  # Показывает порядок поиска методов
```

---
### Переопределение методов
Дочерний класс может **переопределять** методы родительского класса, заменяя их своей реализацией:

```python
class Animal:
    def speak(self):
        return "Звук животного"

class Dog(Animal):
    def speak(self):
        return "Гав!"

class Cat(Animal):
    def speak(self):
        return "Мяу!"

dog = Dog()
cat = Cat()
print(dog.speak())  # "Гав!"
print(cat.speak())  # "Мяу!"
```

В этом примере классы `Dog` и `Cat` переопределяют метод `speak()`, предоставляя свою реализацию.

---
### Наследование и атрибуты класса
Атрибуты класса также наследуются:

```python
class Shape:
    color = "чёрный"  # атрибут класса
    
    def __init__(self, name):
        self.name = name  # атрибут экземпляра

class Circle(Shape):
    radius = 0  # новый атрибут класса
    
    def __init__(self, name, radius):
        super().__init__(name)
        self.radius = radius

circle = Circle("Круг", 5)
print(circle.color)   # "чёрный" - унаследовано от Shape
print(circle.name)    # "Круг" - инициализировано через конструктор Shape
print(circle.radius)  # 5 - установлено в Circle
```

---
### Практические рекомендации по наследованию
1. **Не злоупотребляйте наследованием** — иногда композиция (включение одного объекта в другой) предпочтительнее.
2. **Используйте наследование для общего поведения** — если разные классы имеют общую функциональность, имеет смысл вынести её в базовый класс.
3. **Следуйте принципу подстановки Лисков** — объекты подклассов должны корректно заменять объекты базовых классов.
4. **Осторожно с множественным наследованием** — оно мощное, но может запутать код.

---
### Заключение
- **Наследование** — мощный механизм ООП, позволяющий классам получать атрибуты и методы от других классов.
- С помощью наследования можно **избежать дублирования кода** и создавать **иерархии классов**.
- Дочерние классы могут **переопределять** и **расширять** методы родителей.

