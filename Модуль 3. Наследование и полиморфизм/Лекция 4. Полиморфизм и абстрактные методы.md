# Полиморфизм и абстрактные методы
В предыдущих лекциях мы изучили наследование и механизмы делегирования в Python. Сегодня мы рассмотрим полиморфизм — один из ключевых принципов объектно-ориентированного программирования, а также познакомимся с абстрактными методами и классами, которые помогают эффективно реализовать полиморфизм.

---
### Что такое полиморфизм?
**Полиморфизм** (от греч. "многоформенность") — это принцип ООП, который позволяет объектам разных классов реагировать на одно и то же сообщение (вызов метода) по-разному. Проще говоря, это способность объектов с различной реализацией предоставлять один и тот же интерфейс.

Основная идея полиморфизма заключается в том, что вы можете работать с объектами разных классов через единый интерфейс, не заботясь об их конкретном типе.

---
### Виды полиморфизма в Python
В Python можно выделить несколько видов полиморфизма:

1. **Полиморфизм наследования** — когда дочерние классы переопределяют методы родительского класса
2. **Полиморфизм интерфейса** — когда разные классы имеют методы с одинаковыми именами и сигнатурами
3. **Утиная типизация** — "если это выглядит как утка и крякает как утка, то это утка" (проверка поведения, а не типа)
4. **Полиморфизм операторов** — когда одни и те же операторы работают по-разному с разными типами

---
### Полиморфизм наследования
Этот вид полиморфизма реализуется через переопределение методов в дочерних классах:

```python
class Animal:
    def speak(self):
        return "Некоторый звук животного"

class Dog(Animal):
    def speak(self):
        return "Гав!"

class Cat(Animal):
    def speak(self):
        return "Мяу!"

class Duck(Animal):
    def speak(self):
        return "Кря!"

# Функция демонстрирует полиморфное поведение
def animal_sound(animal):
    return animal.speak()

# Использование
dog = Dog()
cat = Cat()
duck = Duck()

print(animal_sound(dog))   # Гав!
print(animal_sound(cat))   # Мяу!
print(animal_sound(duck))  # Кря!
```

В этом примере функция `animal_sound()` работает с любым объектом, у которого есть метод `speak()`, вызывая соответствующую реализацию в зависимости от типа.

---
### Полиморфизм интерфейса и утиная типизация
В некоторых языках программирования полиморфизм интерфейса реализуется через формальные интерфейсы. В Python используется "утиная типизация" — нет необходимости явно указывать, что класс реализует какой-то интерфейс, достаточно просто реализовать нужные методы:

```python
class File:
    def read(self):
        return "Чтение из файла"
    
    def write(self, data):
        return f"Запись в файл: {data}"

class Database:
    def read(self):
        return "Чтение из базы данных"
    
    def write(self, data):
        return f"Запись в базу данных: {data}"

class Network:
    def read(self):
        return "Чтение из сети"
    
    def write(self, data):
        return f"Передача по сети: {data}"

# Функция работает с любым объектом, имеющим методы read и write
def process_data(data_source):
    data = data_source.read()
    return data_source.write("Обработанные данные")

# Использование
file_obj = File()
db_obj = Database()
net_obj = Network()

process_data(file_obj)  # Работает с файлом
process_data(db_obj)    # Работает с базой данных
process_data(net_obj)   # Работает с сетью
```

Здесь функция `process_data()` не заботится о конкретном типе `data_source`, ей важно только наличие методов `read()` и `write()`.

---
### Полиморфизм операторов
Python позволяет переопределять поведение операторов для пользовательских классов с помощью специальных методов (также называемых "магическими" или "дандер" методами):

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    # Переопределяем оператор +
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    # Переопределяем оператор *
    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"

# Использование
v1 = Vector(1, 2)
v2 = Vector(3, 4)

print(v1 + v2)    # Vector(4, 6)
print(v1 * 3)     # Vector(3, 6)
```

Таким образом, операторы `+` и `*` работают совершенно по-разному для разных типов данных (числа, строки, списки, пользовательские классы), демонстрируя полиморфизм.

---
### Преимущества полиморфизма
1. **Гибкость** — можно заменять объекты с одинаковым интерфейсом, не меняя использующий их код
2. **Расширяемость** — легко добавлять новые классы, реализующие тот же интерфейс
3. **Абстракция** — работа с объектами на более высоком уровне абстракции
4. **Уменьшение сложности** — избегаем условных операторов для разных типов

---
### Абстрактные методы и классы
Для обеспечения соблюдения интерфейса во всех производных классах полезно использовать **абстрактные классы** и **абстрактные методы**, подробнее поговорим о них в следующих лекциях, а сейчас достаточно понимать:

**Абстрактный класс** — это класс, который не предназначен для создания экземпляров и служит только как базовый класс для других классов.

**Абстрактный метод** — это метод, который объявлен, но не имеет реализации в абстрактном классе. Он должен быть переопределён в дочерних классах.

В Python абстрактные классы и методы реализуются с помощью модуля `abc` (Abstract Base Classes).

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        """Вычисление площади фигуры"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """Вычисление периметра фигуры"""
        pass

# Создание конкретных классов путем реализации абстрактных методов
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
```

---
### Практические примеры полиморфизма
#### Пример 1: Обработка различных типов данных
```python
def process_data(data):
    try:
        return data.process()
    except AttributeError:
        if isinstance(data, str):
            return f"Обработка строки: {data.upper()}"
        elif isinstance(data, (int, float)):
            return f"Обработка числа: {data * 2}"
        elif isinstance(data, list):
            return f"Обработка списка: {sum(data)}"
        else:
            return "Неизвестный тип данных"

# Класс с методом process
class CustomData:
    def __init__(self, value):
        self.value = value
    
    def process(self):
        return f"Пользовательская обработка: {self.value * 3}"

# Использование
print(process_data("hello"))            # Обработка строки: HELLO
print(process_data(10))                 # Обработка числа: 20
print(process_data([1, 2, 3]))          # Обработка списка: 6
print(process_data(CustomData(5)))      # Пользовательская обработка: 15
```

#### Пример 2: Подключаемые компоненты системы
```python
class Plugin:
    def activate(self):
        raise NotImplementedError("Подклассы должны реализовать activate()")
    
    def deactivate(self):
        raise NotImplementedError("Подклассы должны реализовать deactivate()")

class TextPlugin(Plugin):
    def activate(self):
        return "Текстовый плагин активирован"
    
    def deactivate(self):
        return "Текстовый плагин деактивирован"

class ImagePlugin(Plugin):
    def activate(self):
        return "Плагин изображений активирован"
    
    def deactivate(self):
        return "Плагин изображений деактивирован"

class System:
    def __init__(self):
        self.plugins = []
    
    def register_plugin(self, plugin):
        self.plugins.append(plugin)
    
    def activate_all(self):
        return [plugin.activate() for plugin in self.plugins]
    
    def deactivate_all(self):
        return [plugin.deactivate() for plugin in self.plugins]

# Использование
system = System()
system.register_plugin(TextPlugin())
system.register_plugin(ImagePlugin())

print(system.activate_all())    # ['Текстовый плагин активирован', 'Плагин изображений активирован']
print(system.deactivate_all())  # ['Текстовый плагин деактивирован', 'Плагин изображений деактивирован']
```

---
### Распространённые ошибки при использовании полиморфизма

1. **Неполная реализация интерфейса**:
   ```python
   class Shape(ABC):
       @abstractmethod
       def area(self):
           pass
   
   class BadCircle(Shape):
       # Забыли реализовать area()
       def radius(self):
           return 5
   
   # RuntimeError при создании экземпляра
   ```
2. **Нарушение контракта метода**:
   ```python
   class Base:
       def process(self, data):
           return data * 2
   
   class Derived(Base):
       # Ожидается, что метод принимает один аргумент, но реализация другая
       def process(self):
           return "Обработка"
   
   # TypeError при вызове d.process(10)
   ```
3. **Проверка типа вместо поведения**:
   ```python
   # Плохо: проверка конкретного типа
   def bad_code(animal):
       if isinstance(animal, Dog):
           animal.bark()
       elif isinstance(animal, Cat):
           animal.meow()
   
   # Хорошо: полиморфный подход
   def good_code(animal):
       animal.speak()  # Duck typing
   ```

---
### Рекомендации по использованию полиморфизма и абстрактных методов
1. **Определяйте чёткие интерфейсы** — абстрактные классы помогают документировать, какие методы должны быть реализованы
2. **Следуйте принципу подстановки Лискова** — подклассы должны корректно заменять базовые классы, сохраняя ожидаемое поведение
3. **Предпочитайте композицию наследованию** — часто лучше включить объект как компонент, чем наследоваться от него
4. **Не злоупотребляйте проверками типов** — предпочитайте утиную типизацию явным проверкам `isinstance`

---
### Заключение

- **Полиморфизм** — это принцип, позволяющий работать с объектами разных классов через единый интерфейс.
- В Python полиморфизм реализуется через наследование, утиную типизацию и переопределение операторов.
- **Абстрактные классы и методы** помогают определить интерфейсы, которые должны быть реализованы подклассами.
- Полиморфизм делает код более гибким, расширяемым и поддерживаемым, уменьшая зависимость от конкретных типов.
