# Функция issubclass(). Наследование от встроенных типов и от object
В предыдущей лекции мы познакомились с основами наследования в Python, узнали, как создавать иерархии классов и использовать механизмы переопределения и расширения методов. Сегодня мы углубимся в детали наследования, рассмотрим функцию `issubclass()`, а также изучим особенности наследования от встроенных типов и базового класса `object`.

---
### Функция issubclass()
Функция `issubclass()` — это встроенная функция Python, которая проверяет, является ли один класс подклассом другого. Она возвращает `True`, если первый аргумент является подклассом второго аргумента, и `False` в противном случае.

Синтаксис:
```python
issubclass(класс, класс_или_кортеж_классов)
```

Примеры использования:
```python
class Animal:
    pass

class Dog(Animal):
    pass

class Bulldog(Dog):
    pass

# Прямое наследование
print(issubclass(Dog, Animal))      # True - Dog наследуется от Animal

# Транзитивное наследование
print(issubclass(Bulldog, Animal))  # True - Bulldog наследуется от Animal через Dog

# Класс всегда является подклассом самого себя
print(issubclass(Animal, Animal))   # True 

# Не является подклассом
print(issubclass(Animal, Dog))      # False - Animal не наследуется от Dog
```

Функция `issubclass()` также может принимать кортеж классов в качестве второго аргумента. В этом случае она вернёт `True`, если первый аргумент является подклассом любого класса из кортежа:

```python
class A:
    pass

class B:
    pass

class C(A):
    pass

print(issubclass(C, (A, B)))  # True - C наследуется от A
print(issubclass(C, (B, int)))  # False - C не наследуется ни от B, ни от int
```

---
### Все классы наследуются от object

В Python 3 все классы неявно наследуются от базового класса `object`, даже если это не указано явно. Это означает, что классы без явного родителя автоматически становятся подклассами `object`:

```python
class MyClass:  # Неявно наследуется от object
    pass

print(issubclass(MyClass, object))  # True
```

Эквивалентное определение с явным указанием родителя:
```python
class MyClass(object):  # Явное наследование от object
    pass
```

Базовый класс `object` предоставляет ряд встроенных методов, которые наследуются всеми классами в Python:

- `__new__()` и `__init__()` — для создания и инициализации объектов
- `__str__()` — для строкового представления объекта
- `__repr__()` — для репрезентативного строкового представления
- `__eq__()`, `__lt__()` и другие методы сравнения
- `__hash__()` — для возможности хеширования
- `__dir__()` — для возврата списка атрибутов

Эти методы можно переопределять в своих классах для изменения стандартного поведения.

---
### Наследование от встроенных типов

Python позволяет наследовать от встроенных типов, таких как `list`, `dict`, `str` и других. Это позволяет создавать специализированные версии этих типов с дополнительной функциональностью:

```python
class MyList(list):
    def sum(self):
        """Возвращает сумму элементов списка"""
        return sum(self)
    
    def average(self):
        """Возвращает среднее значение элементов списка"""
        if not self:
            return 0
        return self.sum() / len(self)

# Использование
my_list = MyList([1, 2, 3, 4, 5])
print(my_list)           # [1, 2, 3, 4, 5] - обычный список
print(my_list.sum())     # 15 - наш метод
print(my_list.average()) # 3.0 - наш метод

# Можно использовать все методы стандартного списка
my_list.append(6)
print(my_list)           # [1, 2, 3, 4, 5, 6]
```

Аналогично можно наследовать от других встроенных типов:

```python
class MyDict(dict):
    def invert(self):
        """Возвращает новый словарь с обменом ключей и значений"""
        return MyDict({v: k for k, v in self.items()})

my_dict = MyDict({"a": 1, "b": 2, "c": 3})
print(my_dict)           # {'a': 1, 'b': 2, 'c': 3}
print(my_dict.invert())  # {1: 'a', 2: 'b', 3: 'c'}
```

---
### Особенности наследования от встроенных типов

Хотя наследование от встроенных типов является мощным инструментом, есть некоторые особенности, о которых следует помнить:

1. **Особенности методов `__init__` и `__new__`**:
   У встроенных типов есть определённая логика инициализации, которую важно учитывать при переопределении этих методов.

2. **Не все методы вызывают пользовательские методы**:
   Некоторые операции встроенных типов не будут использовать переопределённые вами методы.

Пример с проблемой:
```python
class MyList(list):
    def __getitem__(self, index):
        print(f"Запрошен индекс {index}")
        return super().__getitem__(index)

my_list = MyList([1, 2, 3])
print(my_list[0])  # Запрошен индекс 0, 1

# Но при некоторых операциях наш метод не вызывается
print(my_list + [4, 5])  # [1, 2, 3, 4, 5], наш метод не вызывался
```

---
### Исследование иерархии наследования

Для исследования иерархии наследования можно использовать атрибут `__mro__` (Method Resolution Order) или метод `mro()`:

```python
class A:
    pass

class B(A):
    pass

class C(B):
    pass

print(C.__mro__)  # (<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
```

Это показывает порядок поиска методов при их вызове. Python сначала ищет метод в самом классе `C`, затем в `B`, затем в `A`, и наконец в `object`.

Также можно использовать функцию `isinstance()` для проверки, является ли объект экземпляром определённого класса:

```python
c = C()
print(isinstance(c, C))       # True
print(isinstance(c, B))       # True
print(isinstance(c, A))       # True
print(isinstance(c, object))  # True
print(isinstance(c, list))    # False
```

---
### Практические примеры наследования от встроенных типов

#### Список с автоматической сортировкой:
```python
class SortedList(list):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.sort()
    
    def append(self, item):
        super().append(item)
        self.sort()
    
    def extend(self, iterable):
        super().extend(iterable)
        self.sort()

sorted_list = SortedList([3, 1, 4, 1, 5, 9, 2, 6])
print(sorted_list)  # [1, 1, 2, 3, 4, 5, 6, 9]

sorted_list.append(7)
print(sorted_list)  # [1, 1, 2, 3, 4, 5, 6, 7, 9]
```

#### Словарь с доступом к значениям по индексу:
```python
class IndexedDict(dict):
    def get_item_at(self, index):
        if not 0 <= index < len(self):
            raise IndexError("Индекс вне диапазона")
        return list(self.items())[index]

indexed_dict = IndexedDict(a=1, b=2, c=3)
print(indexed_dict.get_item_at(1))  # ('b', 2)
```

---
### Преимущества и недостатки наследования от встроенных типов
**Преимущества:**
- Экономия времени — не нужно переопределять все методы встроенного типа
- Соблюдение интерфейса — объект будет вести себя так же, как встроенный тип
- Оптимизация — встроенные типы обычно реализованы на C и работают быстроs
**Недостатки:**
- Сложность — внутреннее поведение встроенных типов может быть сложным
- Ограничения — не все методы могут быть успешно переопределены
- Неожиданные взаимодействия — некоторые встроенные операции могут не вызывать ваши переопределённые методы

---
### Рекомендации по наследованию
1. **Предпочитайте композицию наследованию**, если возможно:
   ```python
   class MyCollection:
       def __init__(self):
           self._data = []  # Композиция
   ```
2. **Используйте наследование от встроенных типов для специализации**, когда это имеет смысл:
   ```python
   class UniqueList(list):
       def append(self, item):
           if item not in self:
               super().append(item)
   ```
3. **Не злоупотребляйте прямым наследованием от нескольких встроенных типов** — это может привести к сложностям
4. **Будьте внимательны с переопределением специальных методов** встроенных типов

---
### Заключение
- Функция `issubclass()` позволяет проверить, является ли один класс подклассом другого.
- В Python 3 все классы наследуются от базового класса `object`, даже если это не указано явно.
- Python позволяет наследовать от встроенных типов, что даёт возможность расширять их функциональность.
- При наследовании от встроенных типов нужно учитывать их особенности и ограничения.
- Атрибут `__mro__` и функции `isinstance()` и `issubclass()` помогают исследовать иерархию наследования.
